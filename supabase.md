# Supabase Database Initialization for MCQ Test Platform

This file contains all the necessary SQL commands to set up the database schema, user roles, and security policies for the MCQ Test Platform application.

## How to Use

1.  Navigate to your Supabase project dashboard.
2.  Go to the **SQL Editor** section.
3.  Click on **+ New query**.
4.  Copy the entire content of the SQL script below and paste it into the editor.
5.  Click **Run** to execute the script.

**WARNING: Running this script will completely delete all existing data in the platform's tables and recreate them from scratch. This is intended for initial setup or a complete reset. It will preserve your users but repopulate their profiles.**

---

## 1. SQL Schema and Policies

```sql
-- =================================================================
-- SECTION 0: CLEAN UP (Makes the script idempotent / re-runnable)
-- =================================================================

-- Drop dependent objects first to avoid errors.
-- Using CASCADE will automatically remove dependent objects like triggers and RLS policies,
-- which is necessary if the script has been run before.
DROP FUNCTION IF EXISTS public.reset_test_session() CASCADE;
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
DROP FUNCTION IF EXISTS public.is_admin() CASCADE;

-- The trigger `on_auth_user_created` is dropped by the CASCADE on handle_new_user,
-- but this explicit drop is kept for clarity and safety.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Drop tables in reverse order of creation due to foreign key constraints
DROP TABLE IF EXISTS public.audit_logs CASCADE;
DROP TABLE IF EXISTS public.student_submissions CASCADE;
DROP TABLE IF EXISTS public.student_answers CASCADE;
DROP TABLE IF EXISTS public.test_sessions CASCADE;
DROP TABLE IF EXISTS public.questions CASCADE;
DROP TABLE IF EXISTS public.tests CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;


-- =================================================================
-- SECTION 1: TABLE CREATION
-- =================================================================

-- 1. PROFILES TABLE
-- Stores public user data, linked to the authentication service.
CREATE TABLE public.profiles (
  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  full_name text,
  university_id text,
  email text,
  role text DEFAULT 'student'::text NOT NULL,
  PRIMARY KEY (id)
);
COMMENT ON TABLE public.profiles IS 'Stores public profile information for each user.';

-- 2. TESTS TABLE
-- Stores test metadata created by admins.
CREATE TABLE public.tests (
  id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
  title text NOT NULL,
  description text,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  created_by uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE
);
COMMENT ON TABLE public.tests IS 'Contains all the tests created by administrators.';

-- 3. QUESTIONS TABLE
-- Stores questions and their options for each test.
CREATE TABLE public.questions (
  id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
  test_id uuid NOT NULL REFERENCES public.tests ON DELETE CASCADE,
  question_text text NOT NULL,
  options jsonb NOT NULL,
  created_at timestamp with time zone DEFAULT now() NOT NULL
);
COMMENT ON TABLE public.questions IS 'Stores individual questions for each test, linked by test_id.';
CREATE INDEX ON public.questions(test_id);

-- 4. TEST SESSIONS TABLE
-- A singleton table to manage the state of the active test.
CREATE TABLE public.test_sessions (
  id text NOT NULL PRIMARY KEY, -- Should always be 'active_session'
  test_id uuid REFERENCES public.tests ON DELETE SET NULL,
  status text NOT NULL DEFAULT 'waiting'::text,
  duration_minutes integer NOT NULL DEFAULT 60,
  start_time timestamp with time zone,
  test_title text,
  last_paused_at timestamp with time zone,
  total_paused_duration_seconds integer NOT NULL DEFAULT 0
);
COMMENT ON TABLE public.test_sessions IS 'Manages the live state of the test session (e.g., waiting, started).';

-- 5. STUDENT ANSWERS TABLE
-- Stores answers submitted by students during a test.
CREATE TABLE public.student_answers (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id text NOT NULL, -- Should always be 'active_session'
  student_id uuid NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
  question_id uuid NOT NULL REFERENCES public.questions ON DELETE CASCADE,
  selected_option_index integer NOT NULL,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  -- Unique constraint to allow easy upserting of answers.
  CONSTRAINT uq_student_answer UNIQUE (session_id, student_id, question_id)
);
COMMENT ON TABLE public.student_answers IS 'Records each student''s answer to a question.';
CREATE INDEX ON public.student_answers(student_id, session_id);


-- 6. STUDENT SUBMISSIONS TABLE
-- Tracks when a student has finalized their test submission for a session.
CREATE TABLE public.student_submissions (
  session_id text NOT NULL, -- Should always be 'active_session'
  student_id uuid NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
  submitted_at timestamp with time zone DEFAULT now() NOT NULL,
  PRIMARY KEY (session_id, student_id)
);
COMMENT ON TABLE public.student_submissions IS 'Records when a student has finalized their test submission.';


-- 7. AUDIT LOGS TABLE
CREATE TABLE public.audit_logs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  user_id uuid REFERENCES auth.users ON DELETE SET NULL,
  user_email text,
  action text NOT NULL,
  details jsonb
);
COMMENT ON TABLE public.audit_logs IS 'Tracks significant events and actions within the application for auditing purposes.';


-- =================================================================
-- SECTION 2: DATA SEEDING & INITIALIZATION
-- =================================================================

-- Initialize the single active session row.
INSERT INTO public.test_sessions (id, status, duration_minutes, total_paused_duration_seconds)
VALUES ('active_session', 'waiting', 60, 0)
ON CONFLICT (id) DO NOTHING;

-- Repopulate profiles from auth.users, setting the admin role.
-- This ensures existing users are not lost when the script is re-run.
INSERT INTO public.profiles (id, full_name, university_id, email, role)
SELECT
    id,
    raw_user_meta_data->>'full_name',
    raw_user_meta_data->>'university_id',
    email,
    CASE
        WHEN email = 'diepho@gmail.com' THEN 'admin'
        ELSE 'student'
    END AS role
FROM auth.users
ON CONFLICT (id) DO UPDATE SET
  full_name = EXCLUDED.full_name,
  university_id = EXCLUDED.university_id,
  email = EXCLUDED.email,
  role = EXCLUDED.role;


-- =================================================================
-- SECTION 3: AUTOMATION & FUNCTIONS
-- =================================================================

-- Function to create a profile entry when a new user signs up.
-- This handles new registrations after the initial setup.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, university_id, email, role)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'university_id',
    new.email,
    -- Check for the specific admin email during new user creation as a safeguard.
    CASE
        WHEN new.email = 'diepho@gmail.com' THEN 'admin'
        ELSE 'student'
    END
  )
  ON CONFLICT (id) DO UPDATE SET
    full_name = new.raw_user_meta_data->>'full_name',
    university_id = new.raw_user_meta_data->>'university_id',
    email = new.email;
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to execute the function after a new user is added to auth.users.
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Helper function to check if the current user is an admin.
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean AS $$
BEGIN
  IF auth.uid() IS NULL THEN
    RETURN FALSE;
  ELSE
    RETURN (
      SELECT role = 'admin'
      FROM public.profiles
      WHERE id = auth.uid()
    );
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to securely reset the active test session data.
-- This is called by the admin dashboard's "Reset" button.
CREATE OR REPLACE FUNCTION public.reset_test_session()
RETURNS void AS $$
BEGIN
  -- We must check for admin role here because SECURITY DEFINER bypasses RLS.
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'Permission denied: only admins can reset sessions.';
  END IF;

  -- 1. Delete data from the previous session.
  DELETE FROM public.student_answers WHERE session_id = 'active_session';
  DELETE FROM public.student_submissions WHERE session_id = 'active_session';

  -- 2. Update the session state back to 'waiting'.
  -- This makes the entire reset process a single, atomic transaction.
  UPDATE public.test_sessions
  SET 
    status = 'waiting', 
    test_id = NULL, 
    start_time = NULL, 
    test_title = NULL,
    last_paused_at = NULL,
    total_paused_duration_seconds = 0
  WHERE id = 'active_session';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- =================================================================
-- SECTION 4: ROW LEVEL SECURITY (RLS)
-- =================================================================

-- Enable RLS on all tables.
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.test_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.student_answers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.student_submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Profiles Policies
CREATE POLICY "Allow users to view their own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Allow users to update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Allow admins full access to profiles" ON public.profiles FOR ALL USING (public.is_admin());

-- Tests Policies
CREATE POLICY "Allow authenticated users to view tests" ON public.tests FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admins full access to tests" ON public.tests FOR ALL USING (public.is_admin());

-- Questions Policies
CREATE POLICY "Allow authenticated users to view questions" ON public.questions FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admins full access to questions" ON public.questions FOR ALL USING (public.is_admin());

-- Test Sessions Policies
CREATE POLICY "Allow authenticated users to view test session" ON public.test_sessions FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow admins full access to test session" ON public.test_sessions FOR ALL USING (public.is_admin());

-- Student Answers Policies
CREATE POLICY "Allow students to manage their own answers" ON public.student_answers FOR ALL USING (auth.uid() = student_id);
CREATE POLICY "Allow admins full access to answers" ON public.student_answers FOR ALL USING (public.is_admin());

-- Student Submissions Policies
CREATE POLICY "Allow students to submit their own test" ON public.student_submissions FOR INSERT TO authenticated WITH CHECK (auth.uid() = student_id);
CREATE POLICY "Allow students to view their own submission status" ON public.student_submissions FOR SELECT TO authenticated USING (auth.uid() = student_id);
CREATE POLICY "Allow admins full access to submissions" ON public.student_submissions FOR ALL USING (public.is_admin());

-- Audit Logs Policies
CREATE POLICY "Allow authenticated users to insert their own log entries" ON public.audit_logs FOR INSERT TO authenticated WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all audit logs" ON public.audit_logs FOR SELECT USING (public.is_admin());


-- =================================================================
-- SECTION 5: REALTIME
-- =================================================================

-- Make sure tables broadcast changes to subscribed clients.
ALTER PUBLICATION supabase_realtime ADD TABLE public.test_sessions;
-- Add student_answers to realtime to enable live status dashboard for admin.
ALTER PUBLICATION supabase_realtime ADD TABLE public.student_answers;

```

---

## 2. Create Admin User

The script above automatically handles the admin user setup.

When you run the script, it will create profiles for all existing users in your Supabase authentication. The user with the email `diepho@gmail.com` will be automatically assigned the `admin` role. All other users will be assigned the `student` role.

If you haven't created the `diepho@gmail.com` user yet:
1.  **Sign Up:** Use the application's registration form to create the user `diepho@gmail.com`.
2.  **Re-run the Script:** Run the SQL script from this file again in the Supabase SQL Editor. It is safe to re-run and will update the user's role to `admin`.